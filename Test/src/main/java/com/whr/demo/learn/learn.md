# spring容器关键接口
基础接口：
Resource + ResourceLoader、
BeanDefinition、BeanDefinitionLoader、BeanDefinitionRegister
BeanFactory、ApplicationContext
BeanFactory下的三大子接口：HierarchicalBeanFactory、ListableBeanFactory、AutowireCapableBeanFactory
Aware
bean生命周期接口：
BeanPostProcessor
BeanFactoryPostProcessor
# 细节
1. 我们在xml文件、注解（甚至是磁盘、网络。详细可以查看Resource的实现类）等中定义的组件（比如一个bean）都被spring看做是Resource，spring使用ResourceLoader
将xml、注解等加载成Resource，再由BeanDefinitionReader解析转成BeanDefinition注册到BeanDefinitionRegister。BeanDefinition可类比成一个组件的图纸。
然后循环遍历BeanDefinition集合根据所谓的图纸经过一系列流程来创建bean对象，放入到对象池中（三级缓存）
2. Resource下有多种实现，也就是有多种资源的表示方式（class path，文件系统，网络等） 
3. ResourceLoader官方注解中说是一个策略接口（Strategy interface）
4. DefaultListableBeanFactory实现了BeanDefinitionRegister接口，是BeanDefinition的注册中心。该类中定义了BeanDefinition的多种map集合字段和访问BeanDefinition的多种方法
5. 我们用的AnnotationConfigApplication和ClassPathXmlApplicationContext的基类分别是GenericApplicationContext和AbstractRefreshableApplicationContext
这两个基类中都组合一个DefaultListableBeanFactory类型的属性
6. DefaultListableBeanFactory的基类之一是ConfigurableListableBeanFactory，Conf...这个接口同时继承了ListableBeanFactory和AutowireCapableBeanFactory
7. DefaultListableBeanFactory的基类之一是DefaultSingletonBeanRegistry，该类是单例bean的注册中心（三级缓存的地方）。也就是说，图纸保存中心的父类是
成品保存中心
8. 注解创建的bean中的普通属性（非@Autowried注入的）的值，比如 private String name = "wang";这个"wang"是保存在RootBeanDefinition的attributes
属性中的，不是populate阶段填充的。而且这样的属性本来就是属于对象的，通过构造器创建出来对象就会自带这个属性值，不用注入。
而xml方式创建的bean，使用bean标签的property为属性赋值时是通过populateBean的applyPropertyValues来为属性赋值的
# 后置处理器总结
ApplicationContextAwareProcessor：在doCreateBean的initializeBean方法的调用处理器的before方法时。这个后置处理处理了
EnvironmentAware、MessageSourceAware、ApplicationContextAware等，可以为bean扩展。
一个bean实现了ApplicationContextAware接口，为什么就能把ApplicationContext这个IOC容器注入进来，就是这个原因。
AutowiredAnnotationBeanPostProcessor：Autowire等注解依赖注入是通过AutowiredAnnotationBeanPostProcessor后置处理器实现的
# spring的工具类
BeanUtils bean工具类。在创建bean实例中用到
StringUtils
ReflectionUtils 反射工具类。在处理@Autowried注入中用到